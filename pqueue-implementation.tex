
In our paper we attempt to define logical categories that each priority queue could be put into. Initially there are some obvious choices the difference between those which are linearizable and those which are not, the underlying data structure, and/or the underlying technique involved.

\subsection{Skip List Based Priority Queues}

\paragraph{Shavit Lotan Queue} The Shavit Lotan priority queue was the first of a number of skip list-based priority queues. \cite{ShavitLotanQueue} The Shavit Lotan Queue is a lock-free priority queue data-structure where the \texttt{pop-min} method traverses the lowest height/level of the skip list. Since the skip list is a series of sorted linked lists, with the lowest height/level containing all values, threads can remove the top items from the list which have the highest priority. Deletion is done logically, using the atomic swap (or similar CAS) to mark a node as deleted and then physically removing that node at that point or sometime after. The underlying skip list can be lock-free or lock-based, indeed the initial publication used a lock-based skip-list. The algorithm is quiescently consistent as other nodes with a lower value may be skipped over for nodes with a higher value inserted afterwards. However timestamps can be added to each node in order to make the list linearizable \cite{Linearizability}.

\paragraph{Lind{\'e}n Jonsson Queue} The Lind{\'e}n Jonsson Queue \cite{LindenPriority} is a lock-free linearizable priority queue where the \texttt{pop-min} method traverses the lowest height/level of the skip list. The novelty of the Lind{\'e}n Jonsson is a sizable reduction in the number of atomic operations with a new representation of deleted nodes in a skip list and batch deletion. Deleted nodes are not represented by a boolean or a marked next pointer but rather a marked predecessor (node to the left) pointer. The marking is done with an atomic-or operation and is generally considered more efficient than a standard compare and swap. The authors also have a novel batch deletion method for logically deleted nodes piling up at the front of the queue. Batch deletion gives significant performance benefits over traditional priority queues. The length of the logically deleted prefix is given as a tunable parameter, the optimal value of which depends on the workload and the number of processes acting on the priority queue.

\paragraph{SprayList} The last pure skip list based priority queue is the SprayList. The primary contribution of the SprayList is deletion via a probabilistic random walk from the beginning of the list in order to reduce and spread contention. This probabilistic walk is referred to as the \textit{spray} and is paramount to reducing contention from threads. The SprayList is a relaxed concurrent data-structure whereby \texttt{pop-min} will remove from a range of top items in the list. The range and other parameters of the \textit{spray} are initialized by the number of expected processes (concurrency) acting on the queue. The implementation of the \textit{spray} means nodes closer to the beginning are less likely to be \textit{landed-on}, so padding nodes are added to the beginning of the list. Once the SprayList \textit{sprays} to find a node it will continue in the same fashion as the Shavit Lotan Queue and traverse the lowest level of the list until a not deleted node is found. Under high contention the SprayList can scale significantly better than traditional concurrent priority queues, but it can be very sensitive to the choice of spray parameters.

\subsection{Heap/Array Based Priority Queues}

\paragraph{Hunt Heap} Heaps make for extremely efficient serial priority queues having only recently been dethroned by B-Trees.

\paragraph{Mounds} Mounds are a randomized array based 